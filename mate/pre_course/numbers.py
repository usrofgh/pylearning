import math
import random
import sys
# -----------------------------------------------------------------------------------------------------------------------
# числа


print(1j)  # complex number. print 1j
print(type(1j))  # class 'complex'
# print(int(1j)) # can't convert complex to int


a = 'nAn'
b = 'NAN'
print(type(float(a)))  # class float
print(float(b))  # nan


a = 1 + 0.0
print(a)  # 1.0   // (float)


print(round(12.4))  # 12
print(round(12.6))  # 13
print(round(12.5))  # 12
print(round(13.5))  # 14


print(42_000_000)  # 42000000
print(42_000_000e6)  # means 42000000 * (10 ** 6)  // 42000000000000.0
print(42_000_000e-6)  # means 42000000 / (10 ** 6)  // 42.0

print(0.1 + 0.2)  # 0.30000000000000004 - 4 в конце потому что мы не можем представить 0.3 ровно в двоичной системе
print(10e5)  # 1000000.0 // 10e5 != 10 ** 5 так как 1-е - float, 2-е - int
print(int(1e22))  # 10000000000000000000000
print(int(1e23))  # 99999999999999991611392 - 5 битов отдельно отвечают за целую
#  дробную часть, и когда длинна целой части превосходит n-значение, то есть проблемы с точностью
print(1e308)  # 1e+308
print(1e309)  # inf - комп x64, оперировать можно максимум с 64 ноликом/единичкой в float  в отличии от int
print(sys.float_info.max)  # 1.7976931348623157e+308
print(sys.float_info.max + 999_990_000)  # 1.7976931348623157e+308
print(sys.float_info.max + 999_990_001)  # inf
print(math.isinf(float('inf')))  # True
# math.isinf(int('inf')) # Error. cause not float



########################
n = 'nan'
b = 0
if float(n):
    print('number')  # yes. cause nan is a True number
else:
    print('not a number')

if float(b):
    print('number')
else:
    print('not a number')  # yes. cause 0 if false(but number)

n = 'nan'  # also inf. "0" in this case - True
# но лучше просто юзать isnumberic
if n.isnumeric():
    print('number')
else:
    print('not a number')  # yes
########################## вернить ещё сюда, когда нужно будет валидировать число


print(random.random() * 5 + 2)  # от 2 до 7(Исключительно)
'''
1. Берем рандомное число от 0 до 1
2. Умножаем а 5
3. Прибавили 2
'''
print(random.randint(0, 5))  # от 0 до 5 !включительно
#-----------------------------------------------------------------------------------------------------------------------









#-----------------------------------------------------------------------------------------------------------------------
# двоичный код

'''
decimal (10):  321
(3 * 100) + (2 * 10) + (1 * 1)
1 * 10 ** 0 = 1
2 * 10 ** 1 = 20
3 * 10 ** 2 = 300
300 + 20 + 1 = 321

<---- 
binary (2):  111
1 * (2 ** 0) = 2
1 * (2 ** 1) = 2
1 * (2 ** 2) = 4
2 + 2 + 4 = 7

binary (2): 100101
1 * (2 ** 0) = 1
0 * (2 ** 1) = 0
1 * (2 ** 2) = 4
0 * (2 ** 3) = 0
0 * (2 ** 4) = 0
1 * (2 ** 5) = 32
32 + 4 + 1 = 37 (dec)

decimal (10): 100101
1 * (10 ** 0) = 1
0 * (10 ** 1) = 0
1 * (10 ** 2) = 100
0 * (10 ** 3) = 0
0 * (10 ** 4) = 0
1 * (10 ** 5) = 100000
100000 + 100 + 1 = 100101

hex (16): 100101
1 * (16 ** 0) = 1
0 * (16 ** 1) = 0
1 * (16 ** 2) = 256
0 * (16 ** 3) = 0
0 * (16 ** 4) = 0
1 * (16 ** 5) = 1048576
1048576 + 256 + 1 = 1048833


hex:
10 - a
11 - b
12 - c
13 - d
14 - e
15 - f

'''
print(0xff)  # 255
print(int("0xff", 16))  # 255 - конвертируем строку в hex-число
print(bin(111))  # 0b1101111
print(hex(111))  # 0x6f
#-----------------------------------------------------------------------------------------------------------------------






#-----------------------------------------------------------------------------------------------------------------------
# abz байты

print(b'\00\42')  # b'\x00"'
print(rb'\00\42')  # сырые байты: b'\\00\\42'

s = 'я строка'
print(s.encode('utf-8'))  # строку в кодировку b'\xd1\x8f \xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0'
print(s.encode('utf-16'))  # строку в кодировку b'\xff\xfeO\x04 \x00A\x04B\x04@\x04>\x04:\x040\x04'

s = s.encode('utf-8')
print(s.decode('utf-8'))  # я строка

# иногда указвыается неверная кодировка, тогда будет ошибка, можно указывать что делать во время ошибки
s = 'я строка'.encode('cp1251')
#s.decode('utf-8')  # error

# пустая строка. По умолчанию - strict - выводит ошибку. replace - Заменяет ошибочные символы на '\ufffd'(� ������)
print(s.decode('utf-8', 'replace'))  # � ������
print(sys.getdefaultencoding())  # utf-8

#-----------------------------------------------------------------------------------------------------------------------
