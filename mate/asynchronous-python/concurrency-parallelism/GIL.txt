GIL = Global Interpreter Lock. За счет него, python легче, но CPU-bound медленнее.
Не убирают, так как многие либы зависят от GIL

На один интерпретатор выделяется 1 процесс (один глобальный лок на интерпретатор)
GIL запрещает одновременно общаться с двумя клиентами(настоящая параллельность с ядрами - 8 кеш линий)

### зачем ввели GIL, ведь в не во всех языках он есть ###
Хотели чтобы python был простым, поэтому добавили Garbage collector (под капотом юзает reference counting - подсчет
ссылок, для того, чтобы понимать, когда очищать ту или иную ячейку памяти)
user = #0
john = #0
#0 {
name: "John"
}
reference counting = 2
del user, john (ref.count = 0 -> запускается Garbage collector и удаляет из памяти значения)

Если бы не GIL, то можно было бы получать доступ к данным из разных потоков.
В одном потоке удалили user, в другом john, итого ref. count в двух потоках по 1 - Garbage collector не сработал бы,
память засорилась бы - Race condition
------------------->



Конкурентность дает эффективность только тогда, когда есть I/O blocking operations (API, DB access, File handling)
В кассе I/O - processing payment

Если I/O нет, то:
---XXX---------- time axis x
cashier
XXX---XXX------- time axis x

Эффективность кассира никак бы не изменилась