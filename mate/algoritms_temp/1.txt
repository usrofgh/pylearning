Алгоритм - набор инструкций использовавши к-е с входными данными мы получим конкретный р-т

Declarative Programming - когда мы ожидаем от программы получения конкретного р-та не описывая как именно программа
должна это пошагово сделать

Imperative Programming - когда пошагово указываем что делать ф-ции

Свойства алгоритма:
не падать в бесконечный цикл
заершать после нахождения э-та в массиве либо похождения по всему массиву
каждый шаг должен быть простым и понятным и имет только одно значение
не зависит от языка программирования(нет значений к-е свойственны конкретному языку). Например не юзать маг. методы


---Asymptotic analysis---
best case scenario (Ω) - minimum time required. Находим э-т в массиве с первой попытки. Быстрее быть не может
worst case scenario (O) - maximum time required. С последней
average case scenario (θ) - average time required. В середине

---Time and Space complexity---
2 основных фактора алгоритма: необходимая память для него и затрачиваемое время(зависимость к-ва операций от входных данных)
Именно входных, нам не важно сколько операций исп. для константных значений

---Algorithm complexity count---
![](Algorithm complexity count.png):

инициализация i + возврат э-нта + возврат null = 3. if return el then null won't return and vise versa. Тогда == 2.
Зависит от n == 4:
    сравнение i в for
    итерация i в for
    присваивание current_element
    сравнение cur_el с аргументов el

Итого: 4n + 2 - линейная функция(сложность) - O(n). Независимо от входных э-в(10, 100 ...) 4 всегда будет 4. и 2.
Поэтому их не учитываем, итого остается только n
--

![](combine_algrorithm.png)

инициализация result
инициализация i в for
возврат result

n:
итерация i в for
сравнение i в for
инициализация j во вложенном for

n^2
сравнение j в for
итерация j в for
инициализация суммы elms

3n^2 + 3n + 3 = f(x) = ax^2 + bx + c - O(n^2) - квадратичная сложность. Содержит в себе линейную функцию